package main

import (
	"fmt"
	"os"
	"strings"

	"github.com/mjwhitta/errors"
)

func generateFuncs(typ string) string {
	var capType string = strings.ToUpper(typ[0:1]) + typ[1:]
	var sb strings.Builder
	var typeList string = capType + "List"

	// String() func
	sb.WriteString(
		fmt.Sprintf(
			"// String returns a string representation of the %s.\n",
			typeList,
		),
	)
	sb.WriteString(
		fmt.Sprintf("func (list *%s) String() string {\n", typeList),
	)
	sb.WriteString("\tif len(*list) == 0 {\n")
	sb.WriteString("\t\treturn \"[]\"\n")
	sb.WriteString("\t}\n\n")
	sb.WriteString("\treturn fmt.Sprint(*list)\n")
	sb.WriteString("}\n\n")

	// Set() func
	sb.WriteString(
		fmt.Sprintf(
			"// Set appends a %s to a %s.\n",
			typ,
			typeList,
		),
	)
	sb.WriteString(
		fmt.Sprintf(
			"func (list *%s) Set(val string) error {\n",
			typeList,
		),
	)

	switch typ {
	case "float":
		sb.WriteString("\tvar e error\n")
		sb.WriteString(fmt.Sprintf("\tvar v %s64\n\n", typ))
		sb.WriteString(
			fmt.Sprintf(
				"\tif v, e = strconv.Parse%s(val, 64)",
				capType,
			),
		)
		sb.WriteString("; e != nil {\n")
		sb.WriteString(
			"\t\treturn errors.Newf(\"failed to parse %s as ",
		)
		sb.WriteString(typ + ": %w\", val, e)\n")
		sb.WriteString("\t}\n\n")
		sb.WriteString("\t(*list) = append(*list, v)\n")
	case "int", "uint":
		sb.WriteString("\tvar e error\n")
		sb.WriteString(fmt.Sprintf("\tvar v %s64\n\n", typ))
		sb.WriteString(
			fmt.Sprintf(
				"\tif v, e = strconv.Parse%s(val, 0, 64); e != nil {",
				capType,
			),
		)
		sb.WriteString(
			"\n\t\treturn errors.Newf(\"failed to parse %s as ",
		)
		sb.WriteString(typ + ": %w\", val, e)\n")
		sb.WriteString("\t}\n\n")
		sb.WriteString("\t(*list) = append(*list, v)\n")
	case "string":
		sb.WriteString("\t(*list) = append(*list, val)\n")
	}

	sb.WriteString("\n\treturn nil\n")
	sb.WriteString("}\n")

	return sb.String()
}

func generateTypes(typ string) string {
	var capType string = strings.ToUpper(typ[0:1]) + typ[1:]
	var sb strings.Builder
	var typeList string = capType + "List"

	// Type declaration
	sb.WriteString(
		fmt.Sprintf(
			"\n// %s allows setting a value multiple times, as",
			typeList,
		),
	)
	sb.WriteString(
		fmt.Sprintf(" in:\n// --flag=%s1 --flag=%s2\n", typ, typ),
	)
	sb.WriteString(fmt.Sprintf("type %s []%s", typeList, typ))

	switch typ {
	case "float", "int", "uint":
		sb.WriteString("64")
	}

	sb.WriteString("\n")

	return sb.String()
}

func header() string {
	var sb strings.Builder

	sb.WriteString("// Code generated by gentypes; DO NOT EDIT.\n")
	sb.WriteString("package cli\n\n")
	sb.WriteString("import (\n")
	sb.WriteString("\t\"fmt\"\n")
	sb.WriteString("\t\"strconv\"\n\n")
	sb.WriteString("\t\"github.com/mjwhitta/errors\"\n")
	sb.WriteString(")\n")

	return sb.String()
}

func main() {
	var e error
	var f *os.File
	var fn string = "generated.go"
	var types []string = []string{"float", "int", "string", "uint"}

	if f, e = os.Create(fn); e != nil {
		panic(errors.Newf("failed to create %s: %w", fn, e))
	}
	defer func() {
		if e := f.Close(); e != nil {
			panic(e)
		}
	}()

	if _, e = f.WriteString(header()); e != nil {
		panic(e)
	}

	for _, thetype := range types {
		if _, e = f.WriteString(generateTypes(thetype)); e != nil {
			panic(e)
		}
	}

	for _, thetype := range types {
		if _, e = f.WriteString("\n"); e != nil {
			panic(e)
		}

		if _, e = f.WriteString(generateFuncs(thetype)); e != nil {
			panic(e)
		}
	}
}
